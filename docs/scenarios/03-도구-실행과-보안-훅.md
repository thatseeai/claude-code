# 시나리오 3: 보안 가디언의 임무 - Tool 실행과 PreToolUse Hook

## 프롤로그: 위험한 순간

민지는 Claude Code를 사용하여 GitHub Actions 워크플로우 파일을 작성하고 있었다. 빠른 배포를 위해 자동화 스크립트를 추가하려던 참이었다.

```
> GitHub Actions에 배포 스크립트를 추가해줘. PR 제목을 커밋 메시지로 사용하고 싶어.
```

Claude는 즉시 코드를 작성하기 시작했다. 하지만 이 순간, 민지도 Claude도 모르는 사이에 조용한 보안 시스템이 깨어나고 있었다.

이것은 하나의 파일 작성이 어떻게 7단계의 보안 검증을 거치는지에 대한 이야기다.

## 제1막: Tool 호출의 시작 (Tool Call Initiation)

### 장면 1: Claude의 계획

Claude는 민지의 요청을 분석하고 계획을 세웠다:

```
[Claude의 내부 사고]

사용자 요청 분석:
- GitHub Actions 워크플로우 수정 필요
- PR 제목을 커밋 메시지로 사용
- 배포 자동화

계획:
1. .github/workflows/deploy.yml 파일 읽기
2. 새로운 스텝 추가
3. 파일 저장
```

Claude는 먼저 기존 파일을 읽었다:

```
[Read 도구 호출]
file_path: .github/workflows/deploy.yml
```

**결과:**
```yaml
# .github/workflows/deploy.yml

name: Deploy

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to production
        run: ./deploy.sh
```

### 장면 2: 위험한 코드 작성

Claude는 민지의 요청대로 PR 제목을 사용하는 코드를 추가했다:

```yaml
# Claude가 작성하려는 새로운 코드

name: Deploy

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # 새로 추가된 위험한 부분
      - name: Create commit message
        run: |
          echo "Deploying: ${{ github.event.pull_request.title }}" > commit.txt
          git commit -m "${{ github.event.pull_request.title }}"

      - name: Deploy to production
        run: ./deploy.sh
```

Claude는 이제 이 코드를 파일에 저장하려고 했다. **Edit 도구**를 호출할 순간이었다.

## 제2막: PreToolUse Hook의 깨어남 (Hook Activation)

### 장면 3: Hook 시스템의 감지

Claude가 Edit 도구를 호출하는 순간:

```
[Edit 도구 호출 요청]
tool_name: "Edit"
parameters:
  file_path: ".github/workflows/deploy.yml"
  old_string: "..."
  new_string: "... [위험한 코드 포함] ..."
```

하지만 이 요청은 즉시 실행되지 않았다. Claude Code의 도구 실행 파이프라인이 작동하기 시작했다.

```
[Tool Execution Pipeline 시작]

1. Tool Call 수신 ✓
2. Parameter 검증 ✓
3. PreToolUse Hook 체크... ⏳
```

### 장면 4: Hook Matcher의 판단

**파일**: `plugins/security-guidance/hooks/hooks.json`

시스템은 등록된 PreToolUse Hook들을 확인했다:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "python3 ${CLAUDE_PLUGIN_ROOT}/hooks/security_reminder_hook.py"
          }
        ],
        "matcher": "Edit|Write|MultiEdit"
      }
    ]
  }
}
```

**Hook Matcher 분석:**
```
tool_name: "Edit"
matcher: "Edit|Write|MultiEdit"

정규표현식 매칭... ✓
결과: 매치됨!

→ Security Hook 실행 필요
```

### 장면 5: Security Hook의 활성화

시스템은 보안 훅 스크립트를 실행할 준비를 했다:

**파일**: `plugins/security-guidance/hooks/security_reminder_hook.py`

Hook에게 전달되는 입력 데이터:

```json
{
  "session_id": "011CUymoK8z8HKgZKRV7dM8N",
  "tool_name": "Edit",
  "tool_input": {
    "file_path": ".github/workflows/deploy.yml",
    "old_string": "...",
    "new_string": "...\nrun: |\n  git commit -m \"${{ github.event.pull_request.title }}\"\n..."
  }
}
```

이 데이터는 표준 입력(stdin)으로 Python 스크립트에 전달되었다.

## 제3막: 보안 분석 (Security Analysis)

### 장면 6: Security Hook의 내부 작동

Python 스크립트가 실행되기 시작했다:

```python
#!/usr/bin/env python3
# File: plugins/security-guidance/hooks/security_reminder_hook.py

import json
import sys
import os
import re

def main():
    # 1. 입력 데이터 읽기
    input_data = json.loads(sys.stdin.read())

    session_id = input_data["session_id"]
    tool_name = input_data["tool_name"]
    tool_input = input_data["tool_input"]

    # 2. 세션 상태 확인
    state_file = os.path.expanduser(
        f"~/.claude/security_warnings_state_{session_id}.json"
    )

    # 이미 경고를 보여줬는지 확인
    if os.path.exists(state_file):
        with open(state_file, 'r') as f:
            state = json.load(f)
            if state.get("warning_shown"):
                # 이미 보여줬으면 통과
                exit(0)
```

세션 상태 파일을 확인했다. 이번 세션에서는 아직 보안 경고를 보여준 적이 없었다.

```python
    # 3. 파일 내용 추출
    file_content = ""
    if "content" in tool_input:
        file_content = tool_input["content"]
    elif "new_string" in tool_input:
        file_content = tool_input["new_string"]

    # 4. 보안 패턴 정의
    security_patterns = {
        "github_actions_injection": {
            "pattern": r'\$\{\{\s*github\.event\.(issue|pull_request)\.(title|body)',
            "name": "GitHub Actions Script Injection",
            "description": "PR 제목이나 내용을 직접 스크립트에 사용하면 명령어 삽입 공격에 취약합니다.",
            "severity": "HIGH"
        },
        "command_injection": {
            "pattern": r'(child_process\.exec|os\.system|subprocess\.call)\s*\(',
            "name": "Command Injection",
            "description": "사용자 입력을 셸 명령어에 직접 전달하면 위험합니다.",
            "severity": "HIGH"
        },
        "code_injection": {
            "pattern": r'(eval|new Function|exec)\s*\(',
            "name": "Code Injection",
            "description": "동적 코드 실행은 공격자가 임의의 코드를 실행할 수 있게 합니다.",
            "severity": "HIGH"
        },
        "xss": {
            "pattern": r'dangerouslySetInnerHTML|innerHTML\s*=',
            "name": "Cross-Site Scripting (XSS)",
            "description": "HTML 삽입 시 사용자 입력을 sanitize해야 합니다.",
            "severity": "MEDIUM"
        },
        "unsafe_deserialization": {
            "pattern": r'pickle\.loads|yaml\.unsafe_load',
            "name": "Unsafe Deserialization",
            "description": "신뢰할 수 없는 데이터의 역직렬화는 위험합니다.",
            "severity": "HIGH"
        }
    }
```

### 장면 7: 패턴 매칭의 순간

Hook은 작성된 코드를 하나씩 검사하기 시작했다:

```python
    # 5. 보안 패턴 검사
    detected_issues = []

    for pattern_id, pattern_info in security_patterns.items():
        regex = re.compile(pattern_info["pattern"], re.IGNORECASE | re.MULTILINE)
        matches = regex.findall(file_content)

        if matches:
            detected_issues.append({
                "pattern_id": pattern_id,
                "name": pattern_info["name"],
                "description": pattern_info["description"],
                "severity": pattern_info["severity"],
                "matches": matches
            })
```

**검사 과정:**

```
패턴 1: github_actions_injection
정규식: \$\{\{\s*github\.event\.(issue|pull_request)\.(title|body)
파일 내용 검사 중...

매칭 발견!
위치: "${{ github.event.pull_request.title }}"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️  위험 감지!
패턴: GitHub Actions Script Injection
심각도: HIGH
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 장면 8: 경고 메시지 생성

Hook은 감지된 위험에 대한 경고 메시지를 작성했다:

```python
    # 6. 경고 메시지 출력
    if detected_issues:
        print("\n" + "="*70)
        print("⚠️  SECURITY WARNING ⚠️")
        print("="*70 + "\n")

        for issue in detected_issues:
            print(f"🔴 {issue['name']} [{issue['severity']}]")
            print(f"   {issue['description']}\n")

            print(f"   발견된 패턴:")
            for match in issue['matches'][:3]:  # 최대 3개까지만 표시
                print(f"   • {match}")
            print()

        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        print("권장 조치:")
        print("1. 사용자 입력을 직접 스크립트에 사용하지 마세요")
        print("2. 입력값을 sanitize하거나 환경변수로 전달하세요")
        print("3. 최소 권한 원칙을 적용하세요")
        print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")

        # 7. 상태 저장
        with open(state_file, 'w') as f:
            json.dump({"warning_shown": True}, f)

        # 8. 도구 실행 차단 (exit code 2)
        sys.exit(2)

    # 위험이 없으면 통과
    sys.exit(0)
```

## 제4막: 차단의 순간 (Tool Blocking)

### 장면 9: Exit Code 2의 의미

Hook 스크립트가 종료되었다:

```
[Security Hook 실행 결과]
Exit Code: 2

파이프라인 해석:
- Exit Code 0: 도구 실행 허용
- Exit Code 1: 에러 (로그 출력)
- Exit Code 2: 도구 실행 차단 ⚠️
```

Tool Execution Pipeline이 이를 감지했다:

```
[Tool Execution Pipeline]

1. Tool Call 수신 ✓
2. Parameter 검증 ✓
3. PreToolUse Hook 체크 ✓
   └─ security_reminder_hook.py 실행
   └─ Exit Code: 2
   └─ 결과: 🚫 차단됨

4. Tool 실행... ❌ 중단됨
```

Edit 도구는 실행되지 않았다. 파일은 수정되지 않았다.

### 장면 10: 사용자에게 경고 전달

Hook의 출력 메시지가 Claude에게 전달되었고, Claude는 이를 민지에게 전달했다:

```
⚠️  보안 경고가 발생했습니다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 GitHub Actions Script Injection [HIGH]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PR 제목이나 내용을 직접 스크립트에 사용하면 명령어 삽입 공격에 취약합니다.

발견된 패턴:
• ${{ github.event.pull_request.title }}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
권장 조치:
1. 사용자 입력을 직접 스크립트에 사용하지 마세요
2. 입력값을 sanitize하거나 환경변수로 전달하세요
3. 최소 권한 원칙을 적용하세요
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

이 코드는 보안상 위험하여 작성하지 않았습니다.
안전한 대안을 제시해드리겠습니다.
```

## 제5막: 안전한 해결책 (Secure Solution)

### 장면 11: Claude의 재설계

Claude는 보안 경고를 이해하고, 안전한 방법을 다시 설계했다:

```
보안 이슈 분석:

문제: PR 제목을 직접 스크립트에 사용
위험: 공격자가 PR 제목에 악의적인 명령어 삽입 가능
예시: "; rm -rf / #" 같은 제목으로 시스템 파괴 가능

안전한 대안:
1. 환경변수로 전달 (GitHub Actions 자체 처리)
2. JSON으로 파싱 후 escape
3. PR 제목 대신 커밋 SHA 사용
```

Claude는 안전한 코드를 작성했다:

```yaml
# 안전한 버전

name: Deploy

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # 안전한 방법: 환경변수 사용
      - name: Set PR title
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # 환경변수는 GitHub Actions가 자동으로 escape
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_ENV

      - name: Create commit message
        run: |
          # 환경변수 사용 (이미 sanitize됨)
          echo "Deploying: $PR_TITLE" > commit.txt

      - name: Deploy to production
        run: ./deploy.sh
```

### 장면 12: 두 번째 시도

Claude는 이번에는 안전한 코드로 Edit 도구를 다시 호출했다:

```
[Edit 도구 호출 - 2차 시도]
tool_name: "Edit"
parameters:
  file_path: ".github/workflows/deploy.yml"
  new_string: "... [안전한 코드] ..."
```

다시 PreToolUse Hook이 실행되었다:

```python
# Security Hook 재실행

# 1. 세션 상태 확인
state_file = "~/.claude/security_warnings_state_011CUymoK8z8HKgZKRV7dM8N.json"

if os.path.exists(state_file):
    state = json.load(f)
    if state.get("warning_shown"):
        # ✓ 이미 경고를 보여줬음
        # 이번에는 바로 통과
        exit(0)
```

**결과:**
```
[Security Hook 실행 결과]
Exit Code: 0 ✓

이미 이번 세션에서 보안 경고를 보여줬으므로,
추가 경고 없이 통과합니다.
```

```
[Tool Execution Pipeline]

1. Tool Call 수신 ✓
2. Parameter 검증 ✓
3. PreToolUse Hook 체크 ✓
   └─ security_reminder_hook.py 실행
   └─ Exit Code: 0
   └─ 결과: ✓ 통과

4. Tool 실행 ✓
   └─ Edit 도구가 파일을 안전하게 수정함
```

파일이 성공적으로 수정되었다!

## 제6막: 세션 상태 관리 (Session State Management)

### 장면 13: 한 번만 경고하는 이유

민지가 궁금해했다:

```
> 왜 두 번째에는 경고가 안 나왔어요?
```

Claude가 설명했다:

```
보안 훅의 세션별 상태 관리

목적:
- 사용자 경험 개선
- 반복적인 경고로 인한 피로 방지
- 한 세션에서 한 번만 의식을 일깨움

작동 방식:
1. 첫 번째 위험 감지 → 경고 표시 + 도구 차단
2. 상태 파일 생성:
   ~/.claude/security_warnings_state_{session_id}.json
   {
     "warning_shown": true,
     "timestamp": "2025-11-10T10:30:00Z"
   }

3. 같은 세션에서 다시 도구 사용 시:
   - 상태 파일 확인
   - warning_shown: true → 경고 생략, 도구 통과

4. 새로운 세션 시작 시:
   - 새로운 session_id → 새로운 상태 파일
   - 다시 첫 경고가 작동함
```

### 장면 14: 세션의 생명주기

```
[세션 A - 011CUymoK8z8HKgZKRV7dM8N]
10:00 - Claude Code 시작
10:15 - 첫 번째 파일 수정 시도 → 보안 경고 ⚠️
10:20 - 두 번째 파일 수정 시도 → 경고 없음 ✓
10:30 - 세션 종료

[세션 B - 011CUz1234567890ABCDEF]
11:00 - Claude Code 다시 시작 (새 세션)
11:10 - 파일 수정 시도 → 보안 경고 ⚠️ (새 세션이므로)
11:15 - 두 번째 시도 → 경고 없음 ✓
```

## 제7막: Hook System의 전체 구조 (Complete Hook Architecture)

### 장면 15: Hook의 종류

보안 훅은 PreToolUse Hook의 한 예시일 뿐이었다. Hook 시스템은 더 넓은 세계를 가지고 있었다:

```
Hook Types in Claude Code:

1. SessionStart Hook
   - 트리거: 세션 시작 시
   - 용도: 시스템 프롬프트에 컨텍스트 추가
   - 예시:
     • learning-output-style
     • explanatory-output-style
   - 출력: additionalContext (시스템 프롬프트에 삽입)

2. PreToolUse Hook ⭐ (현재 시나리오)
   - 트리거: 도구 실행 직전
   - 용도: 도구 실행 검증 및 차단
   - 예시:
     • security-guidance
   - 출력:
     • Exit Code 0: 통과
     • Exit Code 1: 에러
     • Exit Code 2: 차단
   - Matcher: 특정 도구에만 적용 가능

3. PostToolUse Hook
   - 트리거: 도구 실행 직후
   - 용도: 도구 결과 검증 및 후처리
   - 예시:
     • 파일 포맷팅 자동 실행
     • 로그 기록

4. UserPrompt Hook
   - 트리거: 사용자 입력 시
   - 용도: 입력 전처리 및 증강
   - 예시:
     • 자동 컨텍스트 추가
     • 명령어 변환
```

### 장면 16: Hook의 설정 구조

```json
// plugins/security-guidance/hooks/hooks.json

{
  "description": "보안 가이드 훅",
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "python3 ${CLAUDE_PLUGIN_ROOT}/hooks/security_reminder_hook.py",
            "description": "파일 수정 시 보안 패턴 검사"
          }
        ]
      }
    ]
  }
}
```

**설정 요소 설명:**

```
matcher: "Edit|Write|MultiEdit"
    └─ 정규표현식으로 도구 이름 매칭
    └─ 읽기 전용 도구(Read, Grep)에는 적용 안 됨

command: "python3 ${CLAUDE_PLUGIN_ROOT}/..."
    └─ ${CLAUDE_PLUGIN_ROOT}: 플러그인 루트 디렉토리
    └─ 상대 경로로 스크립트 지정

type: "command"
    └─ 현재는 command 타입만 지원
    └─ 미래에는 JavaScript, WASM 등 가능할 수도
```

## 에필로그: 보안의 균형

### 장면 17: 민지의 깨달음

민지는 처음에는 경고가 번거롭다고 생각했지만, 이제 그 가치를 이해했다.

```
민지의 생각:

"만약 Hook이 없었다면?"
→ 보안 취약점이 있는 코드를 그대로 작성
→ 공격자가 PR 제목에 악의적인 명령어 삽입
→ 프로덕션 서버 손상 가능

"Hook이 너무 많이 경고하면?"
→ 사용자가 피로해져서 무시하게 됨
→ "경고 피로(Alert Fatigue)" 발생

"Claude Code의 접근법"
→ 세션당 한 번만 경고
→ 사용자의 의식을 일깨우되 방해하지 않음
→ 안전한 대안을 자동으로 제시
```

민지는 이제 안전한 GitHub Actions 워크플로우를 가지게 되었다. 그리고 앞으로도 Claude Code의 보안 시스템이 조용히 지켜보고 있다는 것을 알게 되었다.

### 장면 18: 보안 가디언의 속삭임

보안 훅은 말없이 다시 잠들었다. 하지만 언제든 다음 위험이 감지되면, 다시 깨어날 준비가 되어 있었다.

```
[Security Hook State]

현재 세션: 011CUymoK8z8HKgZKRV7dM8N
상태: warning_shown = true
모드: Silent Guard (조용히 감시 중)

검사한 패턴: 5개
감지한 위험: 1개 (차단됨)
허용한 도구: 12개

다음 트리거 대기 중...
```

---

## 기술적 세부사항

### Tool Execution Pipeline 전체 흐름

```
사용자/Agent → Tool Call Request
    ↓
[1. Request Reception]
    ├─ Tool name 확인
    ├─ Parameters 확인
    └─ User permissions 확인
    ↓
[2. PreToolUse Hook Processing]
    ├─ Hook configuration 로드
    ├─ Matcher 패턴 확인
    ├─ Matching hooks 필터링
    ├─ Hook 실행 (순차적)
    │   ├─ Hook stdin에 JSON 전달
    │   ├─ Hook 실행
    │   ├─ Exit code 확인
    │   │   ├─ 0: Continue
    │   │   ├─ 1: Log error, Continue
    │   │   └─ 2: BLOCK tool execution
    │   └─ stdout/stderr 캡처
    └─ 결과: ALLOW or BLOCK
    ↓
[3. Tool Execution] (if ALLOWED)
    ├─ Tool-specific logic 실행
    ├─ File system operations
    ├─ Network requests
    └─ Results 생성
    ↓
[4. PostToolUse Hook Processing] (선택적)
    ├─ Hook 실행
    └─ Results 후처리
    ↓
[5. Return Results]
    └─ Agent/User에게 결과 반환
```

### Security Hook 패턴 상세

| 패턴 ID | 정규식 | 위험도 | 설명 |
|---------|--------|--------|------|
| `github_actions_injection` | `\$\{\{ github.event.(issue\|pull_request).(title\|body)` | HIGH | GitHub Actions workflow injection |
| `command_injection` | `(child_process\.exec\|os\.system\|subprocess\.call)` | HIGH | OS 명령어 실행 취약점 |
| `code_injection` | `(eval\|new Function\|exec)\s*\(` | HIGH | 동적 코드 실행 |
| `xss` | `dangerouslySetInnerHTML\|innerHTML\s*=` | MEDIUM | Cross-Site Scripting |
| `unsafe_deserialization` | `pickle\.loads\|yaml\.unsafe_load` | HIGH | 안전하지 않은 역직렬화 |

### 세션 상태 파일 구조

```json
// ~/.claude/security_warnings_state_{session_id}.json

{
  "warning_shown": true,
  "timestamp": "2025-11-10T10:15:30.123Z",
  "patterns_detected": [
    "github_actions_injection"
  ],
  "tools_blocked": 1,
  "tools_allowed": 12
}
```

### Hook 입력/출력 인터페이스

**Hook 입력 (stdin):**
```json
{
  "session_id": "string",
  "tool_name": "Edit|Write|MultiEdit|...",
  "tool_input": {
    "file_path": "string",
    "content": "string",
    "new_string": "string",
    ...
  },
  "user_id": "string",
  "timestamp": "ISO8601"
}
```

**Hook 출력 (stdout):**
```json
{
  "message": "Optional warning message",
  "metadata": {
    "patterns_found": ["pattern1", "pattern2"],
    "severity": "HIGH|MEDIUM|LOW"
  }
}
```

**Exit Codes:**
- `0`: 도구 실행 허용
- `1`: 에러 (로그 출력하지만 도구는 실행)
- `2`: 도구 실행 차단

### 관련 파일

| 컴포넌트 | 파일 경로 |
|---------|----------|
| Security Hook 설정 | `plugins/security-guidance/hooks/hooks.json` |
| Security Hook 스크립트 | `plugins/security-guidance/hooks/security_reminder_hook.py` |
| 세션 상태 파일 | `~/.claude/security_warnings_state_{session_id}.json` |
| Hook 실행 엔진 | (CLI 내부, 소스코드 미제공) |

### 핵심 개념

1. **PreToolUse Hook**: 도구 실행 전에 검증 및 차단 가능
2. **Matcher Pattern**: 정규식으로 특정 도구에만 Hook 적용
3. **Exit Code Protocol**: 0/1/2로 Hook 결과 전달
4. **Session-scoped State**: 세션별로 상태 관리, 경고 피로 방지
5. **Security Patterns**: 정규식으로 일반적인 보안 취약점 감지

이것이 Claude Code의 보안 시스템이다. 사용자를 방해하지 않으면서도, 조용히 위험을 감지하고 막아주는 가디언인 것이다.

보안은 사용자 경험과 균형을 이루어야 한다. Claude Code의 Hook 시스템은 이 균형을 "세션당 한 번의 경고"라는 우아한 방식으로 달성했다.
